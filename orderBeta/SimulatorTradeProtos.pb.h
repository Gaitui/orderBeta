// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SimulatorTradeProtos.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_SimulatorTradeProtos_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_SimulatorTradeProtos_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_SimulatorTradeProtos_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_SimulatorTradeProtos_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[2]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_SimulatorTradeProtos_2eproto;
namespace tutorial {
class SimulatorTradeOrder;
class SimulatorTradeOrderDefaultTypeInternal;
extern SimulatorTradeOrderDefaultTypeInternal _SimulatorTradeOrder_default_instance_;
class SimulatorTradeReply;
class SimulatorTradeReplyDefaultTypeInternal;
extern SimulatorTradeReplyDefaultTypeInternal _SimulatorTradeReply_default_instance_;
}  // namespace tutorial
PROTOBUF_NAMESPACE_OPEN
template<> ::tutorial::SimulatorTradeOrder* Arena::CreateMaybeMessage<::tutorial::SimulatorTradeOrder>(Arena*);
template<> ::tutorial::SimulatorTradeReply* Arena::CreateMaybeMessage<::tutorial::SimulatorTradeReply>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tutorial {

enum KindEnum : int {
  kNew = 0,
  kCancel = 1,
  kReplace = 2,
  KindEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  KindEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool KindEnum_IsValid(int value);
constexpr KindEnum KindEnum_MIN = kNew;
constexpr KindEnum KindEnum_MAX = kReplace;
constexpr int KindEnum_ARRAYSIZE = KindEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KindEnum_descriptor();
template<typename T>
inline const std::string& KindEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KindEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KindEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KindEnum_descriptor(), enum_t_value);
}
inline bool KindEnum_Parse(
    const std::string& name, KindEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KindEnum>(
    KindEnum_descriptor(), name, value);
}
enum SideEnum : int {
  sNone = 0,
  sBuy = 1,
  sSell = 2,
  SideEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SideEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SideEnum_IsValid(int value);
constexpr SideEnum SideEnum_MIN = sNone;
constexpr SideEnum SideEnum_MAX = sSell;
constexpr int SideEnum_ARRAYSIZE = SideEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SideEnum_descriptor();
template<typename T>
inline const std::string& SideEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SideEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SideEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SideEnum_descriptor(), enum_t_value);
}
inline bool SideEnum_Parse(
    const std::string& name, SideEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SideEnum>(
    SideEnum_descriptor(), name, value);
}
enum OrderTypeEnum : int {
  otNone = 0,
  otMarket = 1,
  otLimit = 2,
  otMarketWithProtection = 3,
  otStop = 4,
  otStopLimit = 5,
  OrderTypeEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OrderTypeEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OrderTypeEnum_IsValid(int value);
constexpr OrderTypeEnum OrderTypeEnum_MIN = otNone;
constexpr OrderTypeEnum OrderTypeEnum_MAX = otStopLimit;
constexpr int OrderTypeEnum_ARRAYSIZE = OrderTypeEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderTypeEnum_descriptor();
template<typename T>
inline const std::string& OrderTypeEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrderTypeEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrderTypeEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrderTypeEnum_descriptor(), enum_t_value);
}
inline bool OrderTypeEnum_Parse(
    const std::string& name, OrderTypeEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderTypeEnum>(
    OrderTypeEnum_descriptor(), name, value);
}
enum OrderStatusEnum : int {
  osNone = 0,
  osPendingNew = 1,
  osNew = 2,
  osPendingReplace = 3,
  osReplaced = 4,
  osPendingCancel = 5,
  osCanceled = 6,
  osPartiallyFilled = 7,
  osFilled = 8,
  osQuoteAccept = 9,
  osExpired = 10,
  osRejected = 11,
  osQuoteRequestAccept = 12,
  OrderStatusEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OrderStatusEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OrderStatusEnum_IsValid(int value);
constexpr OrderStatusEnum OrderStatusEnum_MIN = osNone;
constexpr OrderStatusEnum OrderStatusEnum_MAX = osQuoteRequestAccept;
constexpr int OrderStatusEnum_ARRAYSIZE = OrderStatusEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderStatusEnum_descriptor();
template<typename T>
inline const std::string& OrderStatusEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrderStatusEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrderStatusEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrderStatusEnum_descriptor(), enum_t_value);
}
inline bool OrderStatusEnum_Parse(
    const std::string& name, OrderStatusEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderStatusEnum>(
    OrderStatusEnum_descriptor(), name, value);
}
enum TimeInForceEnum : int {
  tifNone = 0,
  tifROD = 1,
  tifIOC = 2,
  tifFOK = 3,
  tifTFXQ = 8,
  TimeInForceEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TimeInForceEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TimeInForceEnum_IsValid(int value);
constexpr TimeInForceEnum TimeInForceEnum_MIN = tifNone;
constexpr TimeInForceEnum TimeInForceEnum_MAX = tifTFXQ;
constexpr int TimeInForceEnum_ARRAYSIZE = TimeInForceEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TimeInForceEnum_descriptor();
template<typename T>
inline const std::string& TimeInForceEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TimeInForceEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TimeInForceEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TimeInForceEnum_descriptor(), enum_t_value);
}
inline bool TimeInForceEnum_Parse(
    const std::string& name, TimeInForceEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TimeInForceEnum>(
    TimeInForceEnum_descriptor(), name, value);
}
enum MarketEnum : int {
  mNone = 0,
  mFutures = 1,
  mOptions = 2,
  mTSE = 3,
  mOTC = 4,
  mForeignFutures = 5,
  mForeignOptions = 6,
  mForeignStock = 7,
  mCNFutures = 8,
  mCNOptions = 9,
  mES = 10,
  mTSE_ODD = 11,
  mOTC_ODD = 12,
  MarketEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MarketEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MarketEnum_IsValid(int value);
constexpr MarketEnum MarketEnum_MIN = mNone;
constexpr MarketEnum MarketEnum_MAX = mOTC_ODD;
constexpr int MarketEnum_ARRAYSIZE = MarketEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MarketEnum_descriptor();
template<typename T>
inline const std::string& MarketEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MarketEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MarketEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MarketEnum_descriptor(), enum_t_value);
}
inline bool MarketEnum_Parse(
    const std::string& name, MarketEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MarketEnum>(
    MarketEnum_descriptor(), name, value);
}
// ===================================================================

class SimulatorTradeReply :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.SimulatorTradeReply) */ {
 public:
  SimulatorTradeReply();
  virtual ~SimulatorTradeReply();

  SimulatorTradeReply(const SimulatorTradeReply& from);
  SimulatorTradeReply(SimulatorTradeReply&& from) noexcept
    : SimulatorTradeReply() {
    *this = ::std::move(from);
  }

  inline SimulatorTradeReply& operator=(const SimulatorTradeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimulatorTradeReply& operator=(SimulatorTradeReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimulatorTradeReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimulatorTradeReply* internal_default_instance() {
    return reinterpret_cast<const SimulatorTradeReply*>(
               &_SimulatorTradeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SimulatorTradeReply& a, SimulatorTradeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SimulatorTradeReply* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimulatorTradeReply* New() const final {
    return CreateMaybeMessage<SimulatorTradeReply>(nullptr);
  }

  SimulatorTradeReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimulatorTradeReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimulatorTradeReply& from);
  void MergeFrom(const SimulatorTradeReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimulatorTradeReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.SimulatorTradeReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SimulatorTradeProtos_2eproto);
    return ::descriptor_table_SimulatorTradeProtos_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactTimeFieldNumber = 1,
    kSymbolFieldNumber = 3,
    kTSEOrderTypeFieldNumber = 7,
    kOrderIDFieldNumber = 9,
    kStatusCodeFieldNumber = 13,
    kTextFieldNumber = 14,
    kExecIDFieldNumber = 17,
    kSideFieldNumber = 2,
    kOrderQtyFieldNumber = 4,
    kPriceFieldNumber = 5,
    kOrderTypeFieldNumber = 6,
    kTimeInForceFieldNumber = 8,
    kNIDFieldNumber = 10,
    kLeavesQtyFieldNumber = 11,
    kOrderStatusFieldNumber = 12,
    kReportSeqFieldNumber = 15,
    kMarketFieldNumber = 16,
  };
  // string TransactTime = 1;
  void clear_transacttime();
  const std::string& transacttime() const;
  void set_transacttime(const std::string& value);
  void set_transacttime(std::string&& value);
  void set_transacttime(const char* value);
  void set_transacttime(const char* value, size_t size);
  std::string* mutable_transacttime();
  std::string* release_transacttime();
  void set_allocated_transacttime(std::string* transacttime);
  private:
  const std::string& _internal_transacttime() const;
  void _internal_set_transacttime(const std::string& value);
  std::string* _internal_mutable_transacttime();
  public:

  // string Symbol = 3;
  void clear_symbol();
  const std::string& symbol() const;
  void set_symbol(const std::string& value);
  void set_symbol(std::string&& value);
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  std::string* mutable_symbol();
  std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // string TSEOrderType = 7;
  void clear_tseordertype();
  const std::string& tseordertype() const;
  void set_tseordertype(const std::string& value);
  void set_tseordertype(std::string&& value);
  void set_tseordertype(const char* value);
  void set_tseordertype(const char* value, size_t size);
  std::string* mutable_tseordertype();
  std::string* release_tseordertype();
  void set_allocated_tseordertype(std::string* tseordertype);
  private:
  const std::string& _internal_tseordertype() const;
  void _internal_set_tseordertype(const std::string& value);
  std::string* _internal_mutable_tseordertype();
  public:

  // string OrderID = 9;
  void clear_orderid();
  const std::string& orderid() const;
  void set_orderid(const std::string& value);
  void set_orderid(std::string&& value);
  void set_orderid(const char* value);
  void set_orderid(const char* value, size_t size);
  std::string* mutable_orderid();
  std::string* release_orderid();
  void set_allocated_orderid(std::string* orderid);
  private:
  const std::string& _internal_orderid() const;
  void _internal_set_orderid(const std::string& value);
  std::string* _internal_mutable_orderid();
  public:

  // string StatusCode = 13;
  void clear_statuscode();
  const std::string& statuscode() const;
  void set_statuscode(const std::string& value);
  void set_statuscode(std::string&& value);
  void set_statuscode(const char* value);
  void set_statuscode(const char* value, size_t size);
  std::string* mutable_statuscode();
  std::string* release_statuscode();
  void set_allocated_statuscode(std::string* statuscode);
  private:
  const std::string& _internal_statuscode() const;
  void _internal_set_statuscode(const std::string& value);
  std::string* _internal_mutable_statuscode();
  public:

  // string Text = 14;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string ExecID = 17;
  void clear_execid();
  const std::string& execid() const;
  void set_execid(const std::string& value);
  void set_execid(std::string&& value);
  void set_execid(const char* value);
  void set_execid(const char* value, size_t size);
  std::string* mutable_execid();
  std::string* release_execid();
  void set_allocated_execid(std::string* execid);
  private:
  const std::string& _internal_execid() const;
  void _internal_set_execid(const std::string& value);
  std::string* _internal_mutable_execid();
  public:

  // .tutorial.SideEnum Side = 2;
  void clear_side();
  ::tutorial::SideEnum side() const;
  void set_side(::tutorial::SideEnum value);
  private:
  ::tutorial::SideEnum _internal_side() const;
  void _internal_set_side(::tutorial::SideEnum value);
  public:

  // int32 OrderQty = 4;
  void clear_orderqty();
  ::PROTOBUF_NAMESPACE_ID::int32 orderqty() const;
  void set_orderqty(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_orderqty() const;
  void _internal_set_orderqty(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // double Price = 5;
  void clear_price();
  double price() const;
  void set_price(double value);
  private:
  double _internal_price() const;
  void _internal_set_price(double value);
  public:

  // .tutorial.OrderTypeEnum OrderType = 6;
  void clear_ordertype();
  ::tutorial::OrderTypeEnum ordertype() const;
  void set_ordertype(::tutorial::OrderTypeEnum value);
  private:
  ::tutorial::OrderTypeEnum _internal_ordertype() const;
  void _internal_set_ordertype(::tutorial::OrderTypeEnum value);
  public:

  // .tutorial.TimeInForceEnum TimeInForce = 8;
  void clear_timeinforce();
  ::tutorial::TimeInForceEnum timeinforce() const;
  void set_timeinforce(::tutorial::TimeInForceEnum value);
  private:
  ::tutorial::TimeInForceEnum _internal_timeinforce() const;
  void _internal_set_timeinforce(::tutorial::TimeInForceEnum value);
  public:

  // int64 NID = 10;
  void clear_nid();
  ::PROTOBUF_NAMESPACE_ID::int64 nid() const;
  void set_nid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_nid() const;
  void _internal_set_nid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 LeavesQty = 11;
  void clear_leavesqty();
  ::PROTOBUF_NAMESPACE_ID::int32 leavesqty() const;
  void set_leavesqty(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_leavesqty() const;
  void _internal_set_leavesqty(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .tutorial.OrderStatusEnum OrderStatus = 12;
  void clear_orderstatus();
  ::tutorial::OrderStatusEnum orderstatus() const;
  void set_orderstatus(::tutorial::OrderStatusEnum value);
  private:
  ::tutorial::OrderStatusEnum _internal_orderstatus() const;
  void _internal_set_orderstatus(::tutorial::OrderStatusEnum value);
  public:

  // int32 ReportSeq = 15;
  void clear_reportseq();
  ::PROTOBUF_NAMESPACE_ID::int32 reportseq() const;
  void set_reportseq(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_reportseq() const;
  void _internal_set_reportseq(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .tutorial.MarketEnum Market = 16;
  void clear_market();
  ::tutorial::MarketEnum market() const;
  void set_market(::tutorial::MarketEnum value);
  private:
  ::tutorial::MarketEnum _internal_market() const;
  void _internal_set_market(::tutorial::MarketEnum value);
  public:

  // @@protoc_insertion_point(class_scope:tutorial.SimulatorTradeReply)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transacttime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tseordertype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orderid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr statuscode_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execid_;
  int side_;
  ::PROTOBUF_NAMESPACE_ID::int32 orderqty_;
  double price_;
  int ordertype_;
  int timeinforce_;
  ::PROTOBUF_NAMESPACE_ID::int64 nid_;
  ::PROTOBUF_NAMESPACE_ID::int32 leavesqty_;
  int orderstatus_;
  ::PROTOBUF_NAMESPACE_ID::int32 reportseq_;
  int market_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SimulatorTradeProtos_2eproto;
};
// -------------------------------------------------------------------

class SimulatorTradeOrder :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.SimulatorTradeOrder) */ {
 public:
  SimulatorTradeOrder();
  virtual ~SimulatorTradeOrder();

  SimulatorTradeOrder(const SimulatorTradeOrder& from);
  SimulatorTradeOrder(SimulatorTradeOrder&& from) noexcept
    : SimulatorTradeOrder() {
    *this = ::std::move(from);
  }

  inline SimulatorTradeOrder& operator=(const SimulatorTradeOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimulatorTradeOrder& operator=(SimulatorTradeOrder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimulatorTradeOrder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimulatorTradeOrder* internal_default_instance() {
    return reinterpret_cast<const SimulatorTradeOrder*>(
               &_SimulatorTradeOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SimulatorTradeOrder& a, SimulatorTradeOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(SimulatorTradeOrder* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimulatorTradeOrder* New() const final {
    return CreateMaybeMessage<SimulatorTradeOrder>(nullptr);
  }

  SimulatorTradeOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimulatorTradeOrder>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimulatorTradeOrder& from);
  void MergeFrom(const SimulatorTradeOrder& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimulatorTradeOrder* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.SimulatorTradeOrder";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SimulatorTradeProtos_2eproto);
    return ::descriptor_table_SimulatorTradeProtos_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactTimeFieldNumber = 1,
    kSymbolFieldNumber = 3,
    kTSEOrderTypeFieldNumber = 7,
    kOrderIDFieldNumber = 11,
    kSideFieldNumber = 2,
    kOrderQtyFieldNumber = 4,
    kPriceFieldNumber = 5,
    kOrderTypeFieldNumber = 6,
    kTimeInForceFieldNumber = 8,
    kNIDFieldNumber = 9,
    kMarketFieldNumber = 10,
    kKindFieldNumber = 12,
  };
  // string TransactTime = 1;
  void clear_transacttime();
  const std::string& transacttime() const;
  void set_transacttime(const std::string& value);
  void set_transacttime(std::string&& value);
  void set_transacttime(const char* value);
  void set_transacttime(const char* value, size_t size);
  std::string* mutable_transacttime();
  std::string* release_transacttime();
  void set_allocated_transacttime(std::string* transacttime);
  private:
  const std::string& _internal_transacttime() const;
  void _internal_set_transacttime(const std::string& value);
  std::string* _internal_mutable_transacttime();
  public:

  // string Symbol = 3;
  void clear_symbol();
  const std::string& symbol() const;
  void set_symbol(const std::string& value);
  void set_symbol(std::string&& value);
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  std::string* mutable_symbol();
  std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // string TSEOrderType = 7;
  void clear_tseordertype();
  const std::string& tseordertype() const;
  void set_tseordertype(const std::string& value);
  void set_tseordertype(std::string&& value);
  void set_tseordertype(const char* value);
  void set_tseordertype(const char* value, size_t size);
  std::string* mutable_tseordertype();
  std::string* release_tseordertype();
  void set_allocated_tseordertype(std::string* tseordertype);
  private:
  const std::string& _internal_tseordertype() const;
  void _internal_set_tseordertype(const std::string& value);
  std::string* _internal_mutable_tseordertype();
  public:

  // string OrderID = 11;
  void clear_orderid();
  const std::string& orderid() const;
  void set_orderid(const std::string& value);
  void set_orderid(std::string&& value);
  void set_orderid(const char* value);
  void set_orderid(const char* value, size_t size);
  std::string* mutable_orderid();
  std::string* release_orderid();
  void set_allocated_orderid(std::string* orderid);
  private:
  const std::string& _internal_orderid() const;
  void _internal_set_orderid(const std::string& value);
  std::string* _internal_mutable_orderid();
  public:

  // .tutorial.SideEnum Side = 2;
  void clear_side();
  ::tutorial::SideEnum side() const;
  void set_side(::tutorial::SideEnum value);
  private:
  ::tutorial::SideEnum _internal_side() const;
  void _internal_set_side(::tutorial::SideEnum value);
  public:

  // int32 OrderQty = 4;
  void clear_orderqty();
  ::PROTOBUF_NAMESPACE_ID::int32 orderqty() const;
  void set_orderqty(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_orderqty() const;
  void _internal_set_orderqty(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // double Price = 5;
  void clear_price();
  double price() const;
  void set_price(double value);
  private:
  double _internal_price() const;
  void _internal_set_price(double value);
  public:

  // .tutorial.OrderTypeEnum OrderType = 6;
  void clear_ordertype();
  ::tutorial::OrderTypeEnum ordertype() const;
  void set_ordertype(::tutorial::OrderTypeEnum value);
  private:
  ::tutorial::OrderTypeEnum _internal_ordertype() const;
  void _internal_set_ordertype(::tutorial::OrderTypeEnum value);
  public:

  // .tutorial.TimeInForceEnum TimeInForce = 8;
  void clear_timeinforce();
  ::tutorial::TimeInForceEnum timeinforce() const;
  void set_timeinforce(::tutorial::TimeInForceEnum value);
  private:
  ::tutorial::TimeInForceEnum _internal_timeinforce() const;
  void _internal_set_timeinforce(::tutorial::TimeInForceEnum value);
  public:

  // int64 NID = 9;
  void clear_nid();
  ::PROTOBUF_NAMESPACE_ID::int64 nid() const;
  void set_nid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_nid() const;
  void _internal_set_nid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .tutorial.MarketEnum Market = 10;
  void clear_market();
  ::tutorial::MarketEnum market() const;
  void set_market(::tutorial::MarketEnum value);
  private:
  ::tutorial::MarketEnum _internal_market() const;
  void _internal_set_market(::tutorial::MarketEnum value);
  public:

  // .tutorial.KindEnum Kind = 12;
  void clear_kind();
  ::tutorial::KindEnum kind() const;
  void set_kind(::tutorial::KindEnum value);
  private:
  ::tutorial::KindEnum _internal_kind() const;
  void _internal_set_kind(::tutorial::KindEnum value);
  public:

  // @@protoc_insertion_point(class_scope:tutorial.SimulatorTradeOrder)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transacttime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tseordertype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orderid_;
  int side_;
  ::PROTOBUF_NAMESPACE_ID::int32 orderqty_;
  double price_;
  int ordertype_;
  int timeinforce_;
  ::PROTOBUF_NAMESPACE_ID::int64 nid_;
  int market_;
  int kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SimulatorTradeProtos_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SimulatorTradeReply

// string TransactTime = 1;
inline void SimulatorTradeReply::clear_transacttime() {
  transacttime_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SimulatorTradeReply::transacttime() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeReply.TransactTime)
  return _internal_transacttime();
}
inline void SimulatorTradeReply::set_transacttime(const std::string& value) {
  _internal_set_transacttime(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeReply.TransactTime)
}
inline std::string* SimulatorTradeReply::mutable_transacttime() {
  // @@protoc_insertion_point(field_mutable:tutorial.SimulatorTradeReply.TransactTime)
  return _internal_mutable_transacttime();
}
inline const std::string& SimulatorTradeReply::_internal_transacttime() const {
  return transacttime_.GetNoArena();
}
inline void SimulatorTradeReply::_internal_set_transacttime(const std::string& value) {
  
  transacttime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SimulatorTradeReply::set_transacttime(std::string&& value) {
  
  transacttime_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tutorial.SimulatorTradeReply.TransactTime)
}
inline void SimulatorTradeReply::set_transacttime(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  transacttime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tutorial.SimulatorTradeReply.TransactTime)
}
inline void SimulatorTradeReply::set_transacttime(const char* value, size_t size) {
  
  transacttime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tutorial.SimulatorTradeReply.TransactTime)
}
inline std::string* SimulatorTradeReply::_internal_mutable_transacttime() {
  
  return transacttime_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SimulatorTradeReply::release_transacttime() {
  // @@protoc_insertion_point(field_release:tutorial.SimulatorTradeReply.TransactTime)
  
  return transacttime_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SimulatorTradeReply::set_allocated_transacttime(std::string* transacttime) {
  if (transacttime != nullptr) {
    
  } else {
    
  }
  transacttime_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transacttime);
  // @@protoc_insertion_point(field_set_allocated:tutorial.SimulatorTradeReply.TransactTime)
}

// .tutorial.SideEnum Side = 2;
inline void SimulatorTradeReply::clear_side() {
  side_ = 0;
}
inline ::tutorial::SideEnum SimulatorTradeReply::_internal_side() const {
  return static_cast< ::tutorial::SideEnum >(side_);
}
inline ::tutorial::SideEnum SimulatorTradeReply::side() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeReply.Side)
  return _internal_side();
}
inline void SimulatorTradeReply::_internal_set_side(::tutorial::SideEnum value) {
  
  side_ = value;
}
inline void SimulatorTradeReply::set_side(::tutorial::SideEnum value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeReply.Side)
}

// string Symbol = 3;
inline void SimulatorTradeReply::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SimulatorTradeReply::symbol() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeReply.Symbol)
  return _internal_symbol();
}
inline void SimulatorTradeReply::set_symbol(const std::string& value) {
  _internal_set_symbol(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeReply.Symbol)
}
inline std::string* SimulatorTradeReply::mutable_symbol() {
  // @@protoc_insertion_point(field_mutable:tutorial.SimulatorTradeReply.Symbol)
  return _internal_mutable_symbol();
}
inline const std::string& SimulatorTradeReply::_internal_symbol() const {
  return symbol_.GetNoArena();
}
inline void SimulatorTradeReply::_internal_set_symbol(const std::string& value) {
  
  symbol_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SimulatorTradeReply::set_symbol(std::string&& value) {
  
  symbol_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tutorial.SimulatorTradeReply.Symbol)
}
inline void SimulatorTradeReply::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  symbol_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tutorial.SimulatorTradeReply.Symbol)
}
inline void SimulatorTradeReply::set_symbol(const char* value, size_t size) {
  
  symbol_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tutorial.SimulatorTradeReply.Symbol)
}
inline std::string* SimulatorTradeReply::_internal_mutable_symbol() {
  
  return symbol_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SimulatorTradeReply::release_symbol() {
  // @@protoc_insertion_point(field_release:tutorial.SimulatorTradeReply.Symbol)
  
  return symbol_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SimulatorTradeReply::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:tutorial.SimulatorTradeReply.Symbol)
}

// int32 OrderQty = 4;
inline void SimulatorTradeReply::clear_orderqty() {
  orderqty_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SimulatorTradeReply::_internal_orderqty() const {
  return orderqty_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SimulatorTradeReply::orderqty() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeReply.OrderQty)
  return _internal_orderqty();
}
inline void SimulatorTradeReply::_internal_set_orderqty(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  orderqty_ = value;
}
inline void SimulatorTradeReply::set_orderqty(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_orderqty(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeReply.OrderQty)
}

// double Price = 5;
inline void SimulatorTradeReply::clear_price() {
  price_ = 0;
}
inline double SimulatorTradeReply::_internal_price() const {
  return price_;
}
inline double SimulatorTradeReply::price() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeReply.Price)
  return _internal_price();
}
inline void SimulatorTradeReply::_internal_set_price(double value) {
  
  price_ = value;
}
inline void SimulatorTradeReply::set_price(double value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeReply.Price)
}

// .tutorial.OrderTypeEnum OrderType = 6;
inline void SimulatorTradeReply::clear_ordertype() {
  ordertype_ = 0;
}
inline ::tutorial::OrderTypeEnum SimulatorTradeReply::_internal_ordertype() const {
  return static_cast< ::tutorial::OrderTypeEnum >(ordertype_);
}
inline ::tutorial::OrderTypeEnum SimulatorTradeReply::ordertype() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeReply.OrderType)
  return _internal_ordertype();
}
inline void SimulatorTradeReply::_internal_set_ordertype(::tutorial::OrderTypeEnum value) {
  
  ordertype_ = value;
}
inline void SimulatorTradeReply::set_ordertype(::tutorial::OrderTypeEnum value) {
  _internal_set_ordertype(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeReply.OrderType)
}

// string TSEOrderType = 7;
inline void SimulatorTradeReply::clear_tseordertype() {
  tseordertype_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SimulatorTradeReply::tseordertype() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeReply.TSEOrderType)
  return _internal_tseordertype();
}
inline void SimulatorTradeReply::set_tseordertype(const std::string& value) {
  _internal_set_tseordertype(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeReply.TSEOrderType)
}
inline std::string* SimulatorTradeReply::mutable_tseordertype() {
  // @@protoc_insertion_point(field_mutable:tutorial.SimulatorTradeReply.TSEOrderType)
  return _internal_mutable_tseordertype();
}
inline const std::string& SimulatorTradeReply::_internal_tseordertype() const {
  return tseordertype_.GetNoArena();
}
inline void SimulatorTradeReply::_internal_set_tseordertype(const std::string& value) {
  
  tseordertype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SimulatorTradeReply::set_tseordertype(std::string&& value) {
  
  tseordertype_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tutorial.SimulatorTradeReply.TSEOrderType)
}
inline void SimulatorTradeReply::set_tseordertype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tseordertype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tutorial.SimulatorTradeReply.TSEOrderType)
}
inline void SimulatorTradeReply::set_tseordertype(const char* value, size_t size) {
  
  tseordertype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tutorial.SimulatorTradeReply.TSEOrderType)
}
inline std::string* SimulatorTradeReply::_internal_mutable_tseordertype() {
  
  return tseordertype_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SimulatorTradeReply::release_tseordertype() {
  // @@protoc_insertion_point(field_release:tutorial.SimulatorTradeReply.TSEOrderType)
  
  return tseordertype_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SimulatorTradeReply::set_allocated_tseordertype(std::string* tseordertype) {
  if (tseordertype != nullptr) {
    
  } else {
    
  }
  tseordertype_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tseordertype);
  // @@protoc_insertion_point(field_set_allocated:tutorial.SimulatorTradeReply.TSEOrderType)
}

// .tutorial.TimeInForceEnum TimeInForce = 8;
inline void SimulatorTradeReply::clear_timeinforce() {
  timeinforce_ = 0;
}
inline ::tutorial::TimeInForceEnum SimulatorTradeReply::_internal_timeinforce() const {
  return static_cast< ::tutorial::TimeInForceEnum >(timeinforce_);
}
inline ::tutorial::TimeInForceEnum SimulatorTradeReply::timeinforce() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeReply.TimeInForce)
  return _internal_timeinforce();
}
inline void SimulatorTradeReply::_internal_set_timeinforce(::tutorial::TimeInForceEnum value) {
  
  timeinforce_ = value;
}
inline void SimulatorTradeReply::set_timeinforce(::tutorial::TimeInForceEnum value) {
  _internal_set_timeinforce(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeReply.TimeInForce)
}

// string OrderID = 9;
inline void SimulatorTradeReply::clear_orderid() {
  orderid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SimulatorTradeReply::orderid() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeReply.OrderID)
  return _internal_orderid();
}
inline void SimulatorTradeReply::set_orderid(const std::string& value) {
  _internal_set_orderid(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeReply.OrderID)
}
inline std::string* SimulatorTradeReply::mutable_orderid() {
  // @@protoc_insertion_point(field_mutable:tutorial.SimulatorTradeReply.OrderID)
  return _internal_mutable_orderid();
}
inline const std::string& SimulatorTradeReply::_internal_orderid() const {
  return orderid_.GetNoArena();
}
inline void SimulatorTradeReply::_internal_set_orderid(const std::string& value) {
  
  orderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SimulatorTradeReply::set_orderid(std::string&& value) {
  
  orderid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tutorial.SimulatorTradeReply.OrderID)
}
inline void SimulatorTradeReply::set_orderid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  orderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tutorial.SimulatorTradeReply.OrderID)
}
inline void SimulatorTradeReply::set_orderid(const char* value, size_t size) {
  
  orderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tutorial.SimulatorTradeReply.OrderID)
}
inline std::string* SimulatorTradeReply::_internal_mutable_orderid() {
  
  return orderid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SimulatorTradeReply::release_orderid() {
  // @@protoc_insertion_point(field_release:tutorial.SimulatorTradeReply.OrderID)
  
  return orderid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SimulatorTradeReply::set_allocated_orderid(std::string* orderid) {
  if (orderid != nullptr) {
    
  } else {
    
  }
  orderid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), orderid);
  // @@protoc_insertion_point(field_set_allocated:tutorial.SimulatorTradeReply.OrderID)
}

// int64 NID = 10;
inline void SimulatorTradeReply::clear_nid() {
  nid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimulatorTradeReply::_internal_nid() const {
  return nid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimulatorTradeReply::nid() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeReply.NID)
  return _internal_nid();
}
inline void SimulatorTradeReply::_internal_set_nid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  nid_ = value;
}
inline void SimulatorTradeReply::set_nid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_nid(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeReply.NID)
}

// int32 LeavesQty = 11;
inline void SimulatorTradeReply::clear_leavesqty() {
  leavesqty_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SimulatorTradeReply::_internal_leavesqty() const {
  return leavesqty_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SimulatorTradeReply::leavesqty() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeReply.LeavesQty)
  return _internal_leavesqty();
}
inline void SimulatorTradeReply::_internal_set_leavesqty(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  leavesqty_ = value;
}
inline void SimulatorTradeReply::set_leavesqty(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_leavesqty(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeReply.LeavesQty)
}

// .tutorial.OrderStatusEnum OrderStatus = 12;
inline void SimulatorTradeReply::clear_orderstatus() {
  orderstatus_ = 0;
}
inline ::tutorial::OrderStatusEnum SimulatorTradeReply::_internal_orderstatus() const {
  return static_cast< ::tutorial::OrderStatusEnum >(orderstatus_);
}
inline ::tutorial::OrderStatusEnum SimulatorTradeReply::orderstatus() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeReply.OrderStatus)
  return _internal_orderstatus();
}
inline void SimulatorTradeReply::_internal_set_orderstatus(::tutorial::OrderStatusEnum value) {
  
  orderstatus_ = value;
}
inline void SimulatorTradeReply::set_orderstatus(::tutorial::OrderStatusEnum value) {
  _internal_set_orderstatus(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeReply.OrderStatus)
}

// string StatusCode = 13;
inline void SimulatorTradeReply::clear_statuscode() {
  statuscode_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SimulatorTradeReply::statuscode() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeReply.StatusCode)
  return _internal_statuscode();
}
inline void SimulatorTradeReply::set_statuscode(const std::string& value) {
  _internal_set_statuscode(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeReply.StatusCode)
}
inline std::string* SimulatorTradeReply::mutable_statuscode() {
  // @@protoc_insertion_point(field_mutable:tutorial.SimulatorTradeReply.StatusCode)
  return _internal_mutable_statuscode();
}
inline const std::string& SimulatorTradeReply::_internal_statuscode() const {
  return statuscode_.GetNoArena();
}
inline void SimulatorTradeReply::_internal_set_statuscode(const std::string& value) {
  
  statuscode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SimulatorTradeReply::set_statuscode(std::string&& value) {
  
  statuscode_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tutorial.SimulatorTradeReply.StatusCode)
}
inline void SimulatorTradeReply::set_statuscode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  statuscode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tutorial.SimulatorTradeReply.StatusCode)
}
inline void SimulatorTradeReply::set_statuscode(const char* value, size_t size) {
  
  statuscode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tutorial.SimulatorTradeReply.StatusCode)
}
inline std::string* SimulatorTradeReply::_internal_mutable_statuscode() {
  
  return statuscode_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SimulatorTradeReply::release_statuscode() {
  // @@protoc_insertion_point(field_release:tutorial.SimulatorTradeReply.StatusCode)
  
  return statuscode_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SimulatorTradeReply::set_allocated_statuscode(std::string* statuscode) {
  if (statuscode != nullptr) {
    
  } else {
    
  }
  statuscode_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), statuscode);
  // @@protoc_insertion_point(field_set_allocated:tutorial.SimulatorTradeReply.StatusCode)
}

// string Text = 14;
inline void SimulatorTradeReply::clear_text() {
  text_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SimulatorTradeReply::text() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeReply.Text)
  return _internal_text();
}
inline void SimulatorTradeReply::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeReply.Text)
}
inline std::string* SimulatorTradeReply::mutable_text() {
  // @@protoc_insertion_point(field_mutable:tutorial.SimulatorTradeReply.Text)
  return _internal_mutable_text();
}
inline const std::string& SimulatorTradeReply::_internal_text() const {
  return text_.GetNoArena();
}
inline void SimulatorTradeReply::_internal_set_text(const std::string& value) {
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SimulatorTradeReply::set_text(std::string&& value) {
  
  text_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tutorial.SimulatorTradeReply.Text)
}
inline void SimulatorTradeReply::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tutorial.SimulatorTradeReply.Text)
}
inline void SimulatorTradeReply::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tutorial.SimulatorTradeReply.Text)
}
inline std::string* SimulatorTradeReply::_internal_mutable_text() {
  
  return text_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SimulatorTradeReply::release_text() {
  // @@protoc_insertion_point(field_release:tutorial.SimulatorTradeReply.Text)
  
  return text_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SimulatorTradeReply::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:tutorial.SimulatorTradeReply.Text)
}

// int32 ReportSeq = 15;
inline void SimulatorTradeReply::clear_reportseq() {
  reportseq_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SimulatorTradeReply::_internal_reportseq() const {
  return reportseq_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SimulatorTradeReply::reportseq() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeReply.ReportSeq)
  return _internal_reportseq();
}
inline void SimulatorTradeReply::_internal_set_reportseq(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  reportseq_ = value;
}
inline void SimulatorTradeReply::set_reportseq(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_reportseq(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeReply.ReportSeq)
}

// .tutorial.MarketEnum Market = 16;
inline void SimulatorTradeReply::clear_market() {
  market_ = 0;
}
inline ::tutorial::MarketEnum SimulatorTradeReply::_internal_market() const {
  return static_cast< ::tutorial::MarketEnum >(market_);
}
inline ::tutorial::MarketEnum SimulatorTradeReply::market() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeReply.Market)
  return _internal_market();
}
inline void SimulatorTradeReply::_internal_set_market(::tutorial::MarketEnum value) {
  
  market_ = value;
}
inline void SimulatorTradeReply::set_market(::tutorial::MarketEnum value) {
  _internal_set_market(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeReply.Market)
}

// string ExecID = 17;
inline void SimulatorTradeReply::clear_execid() {
  execid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SimulatorTradeReply::execid() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeReply.ExecID)
  return _internal_execid();
}
inline void SimulatorTradeReply::set_execid(const std::string& value) {
  _internal_set_execid(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeReply.ExecID)
}
inline std::string* SimulatorTradeReply::mutable_execid() {
  // @@protoc_insertion_point(field_mutable:tutorial.SimulatorTradeReply.ExecID)
  return _internal_mutable_execid();
}
inline const std::string& SimulatorTradeReply::_internal_execid() const {
  return execid_.GetNoArena();
}
inline void SimulatorTradeReply::_internal_set_execid(const std::string& value) {
  
  execid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SimulatorTradeReply::set_execid(std::string&& value) {
  
  execid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tutorial.SimulatorTradeReply.ExecID)
}
inline void SimulatorTradeReply::set_execid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  execid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tutorial.SimulatorTradeReply.ExecID)
}
inline void SimulatorTradeReply::set_execid(const char* value, size_t size) {
  
  execid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tutorial.SimulatorTradeReply.ExecID)
}
inline std::string* SimulatorTradeReply::_internal_mutable_execid() {
  
  return execid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SimulatorTradeReply::release_execid() {
  // @@protoc_insertion_point(field_release:tutorial.SimulatorTradeReply.ExecID)
  
  return execid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SimulatorTradeReply::set_allocated_execid(std::string* execid) {
  if (execid != nullptr) {
    
  } else {
    
  }
  execid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), execid);
  // @@protoc_insertion_point(field_set_allocated:tutorial.SimulatorTradeReply.ExecID)
}

// -------------------------------------------------------------------

// SimulatorTradeOrder

// string TransactTime = 1;
inline void SimulatorTradeOrder::clear_transacttime() {
  transacttime_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SimulatorTradeOrder::transacttime() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeOrder.TransactTime)
  return _internal_transacttime();
}
inline void SimulatorTradeOrder::set_transacttime(const std::string& value) {
  _internal_set_transacttime(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeOrder.TransactTime)
}
inline std::string* SimulatorTradeOrder::mutable_transacttime() {
  // @@protoc_insertion_point(field_mutable:tutorial.SimulatorTradeOrder.TransactTime)
  return _internal_mutable_transacttime();
}
inline const std::string& SimulatorTradeOrder::_internal_transacttime() const {
  return transacttime_.GetNoArena();
}
inline void SimulatorTradeOrder::_internal_set_transacttime(const std::string& value) {
  
  transacttime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SimulatorTradeOrder::set_transacttime(std::string&& value) {
  
  transacttime_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tutorial.SimulatorTradeOrder.TransactTime)
}
inline void SimulatorTradeOrder::set_transacttime(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  transacttime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tutorial.SimulatorTradeOrder.TransactTime)
}
inline void SimulatorTradeOrder::set_transacttime(const char* value, size_t size) {
  
  transacttime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tutorial.SimulatorTradeOrder.TransactTime)
}
inline std::string* SimulatorTradeOrder::_internal_mutable_transacttime() {
  
  return transacttime_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SimulatorTradeOrder::release_transacttime() {
  // @@protoc_insertion_point(field_release:tutorial.SimulatorTradeOrder.TransactTime)
  
  return transacttime_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SimulatorTradeOrder::set_allocated_transacttime(std::string* transacttime) {
  if (transacttime != nullptr) {
    
  } else {
    
  }
  transacttime_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transacttime);
  // @@protoc_insertion_point(field_set_allocated:tutorial.SimulatorTradeOrder.TransactTime)
}

// .tutorial.SideEnum Side = 2;
inline void SimulatorTradeOrder::clear_side() {
  side_ = 0;
}
inline ::tutorial::SideEnum SimulatorTradeOrder::_internal_side() const {
  return static_cast< ::tutorial::SideEnum >(side_);
}
inline ::tutorial::SideEnum SimulatorTradeOrder::side() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeOrder.Side)
  return _internal_side();
}
inline void SimulatorTradeOrder::_internal_set_side(::tutorial::SideEnum value) {
  
  side_ = value;
}
inline void SimulatorTradeOrder::set_side(::tutorial::SideEnum value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeOrder.Side)
}

// string Symbol = 3;
inline void SimulatorTradeOrder::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SimulatorTradeOrder::symbol() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeOrder.Symbol)
  return _internal_symbol();
}
inline void SimulatorTradeOrder::set_symbol(const std::string& value) {
  _internal_set_symbol(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeOrder.Symbol)
}
inline std::string* SimulatorTradeOrder::mutable_symbol() {
  // @@protoc_insertion_point(field_mutable:tutorial.SimulatorTradeOrder.Symbol)
  return _internal_mutable_symbol();
}
inline const std::string& SimulatorTradeOrder::_internal_symbol() const {
  return symbol_.GetNoArena();
}
inline void SimulatorTradeOrder::_internal_set_symbol(const std::string& value) {
  
  symbol_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SimulatorTradeOrder::set_symbol(std::string&& value) {
  
  symbol_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tutorial.SimulatorTradeOrder.Symbol)
}
inline void SimulatorTradeOrder::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  symbol_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tutorial.SimulatorTradeOrder.Symbol)
}
inline void SimulatorTradeOrder::set_symbol(const char* value, size_t size) {
  
  symbol_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tutorial.SimulatorTradeOrder.Symbol)
}
inline std::string* SimulatorTradeOrder::_internal_mutable_symbol() {
  
  return symbol_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SimulatorTradeOrder::release_symbol() {
  // @@protoc_insertion_point(field_release:tutorial.SimulatorTradeOrder.Symbol)
  
  return symbol_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SimulatorTradeOrder::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:tutorial.SimulatorTradeOrder.Symbol)
}

// int32 OrderQty = 4;
inline void SimulatorTradeOrder::clear_orderqty() {
  orderqty_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SimulatorTradeOrder::_internal_orderqty() const {
  return orderqty_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SimulatorTradeOrder::orderqty() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeOrder.OrderQty)
  return _internal_orderqty();
}
inline void SimulatorTradeOrder::_internal_set_orderqty(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  orderqty_ = value;
}
inline void SimulatorTradeOrder::set_orderqty(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_orderqty(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeOrder.OrderQty)
}

// double Price = 5;
inline void SimulatorTradeOrder::clear_price() {
  price_ = 0;
}
inline double SimulatorTradeOrder::_internal_price() const {
  return price_;
}
inline double SimulatorTradeOrder::price() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeOrder.Price)
  return _internal_price();
}
inline void SimulatorTradeOrder::_internal_set_price(double value) {
  
  price_ = value;
}
inline void SimulatorTradeOrder::set_price(double value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeOrder.Price)
}

// .tutorial.OrderTypeEnum OrderType = 6;
inline void SimulatorTradeOrder::clear_ordertype() {
  ordertype_ = 0;
}
inline ::tutorial::OrderTypeEnum SimulatorTradeOrder::_internal_ordertype() const {
  return static_cast< ::tutorial::OrderTypeEnum >(ordertype_);
}
inline ::tutorial::OrderTypeEnum SimulatorTradeOrder::ordertype() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeOrder.OrderType)
  return _internal_ordertype();
}
inline void SimulatorTradeOrder::_internal_set_ordertype(::tutorial::OrderTypeEnum value) {
  
  ordertype_ = value;
}
inline void SimulatorTradeOrder::set_ordertype(::tutorial::OrderTypeEnum value) {
  _internal_set_ordertype(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeOrder.OrderType)
}

// string TSEOrderType = 7;
inline void SimulatorTradeOrder::clear_tseordertype() {
  tseordertype_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SimulatorTradeOrder::tseordertype() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeOrder.TSEOrderType)
  return _internal_tseordertype();
}
inline void SimulatorTradeOrder::set_tseordertype(const std::string& value) {
  _internal_set_tseordertype(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeOrder.TSEOrderType)
}
inline std::string* SimulatorTradeOrder::mutable_tseordertype() {
  // @@protoc_insertion_point(field_mutable:tutorial.SimulatorTradeOrder.TSEOrderType)
  return _internal_mutable_tseordertype();
}
inline const std::string& SimulatorTradeOrder::_internal_tseordertype() const {
  return tseordertype_.GetNoArena();
}
inline void SimulatorTradeOrder::_internal_set_tseordertype(const std::string& value) {
  
  tseordertype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SimulatorTradeOrder::set_tseordertype(std::string&& value) {
  
  tseordertype_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tutorial.SimulatorTradeOrder.TSEOrderType)
}
inline void SimulatorTradeOrder::set_tseordertype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tseordertype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tutorial.SimulatorTradeOrder.TSEOrderType)
}
inline void SimulatorTradeOrder::set_tseordertype(const char* value, size_t size) {
  
  tseordertype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tutorial.SimulatorTradeOrder.TSEOrderType)
}
inline std::string* SimulatorTradeOrder::_internal_mutable_tseordertype() {
  
  return tseordertype_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SimulatorTradeOrder::release_tseordertype() {
  // @@protoc_insertion_point(field_release:tutorial.SimulatorTradeOrder.TSEOrderType)
  
  return tseordertype_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SimulatorTradeOrder::set_allocated_tseordertype(std::string* tseordertype) {
  if (tseordertype != nullptr) {
    
  } else {
    
  }
  tseordertype_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tseordertype);
  // @@protoc_insertion_point(field_set_allocated:tutorial.SimulatorTradeOrder.TSEOrderType)
}

// .tutorial.TimeInForceEnum TimeInForce = 8;
inline void SimulatorTradeOrder::clear_timeinforce() {
  timeinforce_ = 0;
}
inline ::tutorial::TimeInForceEnum SimulatorTradeOrder::_internal_timeinforce() const {
  return static_cast< ::tutorial::TimeInForceEnum >(timeinforce_);
}
inline ::tutorial::TimeInForceEnum SimulatorTradeOrder::timeinforce() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeOrder.TimeInForce)
  return _internal_timeinforce();
}
inline void SimulatorTradeOrder::_internal_set_timeinforce(::tutorial::TimeInForceEnum value) {
  
  timeinforce_ = value;
}
inline void SimulatorTradeOrder::set_timeinforce(::tutorial::TimeInForceEnum value) {
  _internal_set_timeinforce(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeOrder.TimeInForce)
}

// int64 NID = 9;
inline void SimulatorTradeOrder::clear_nid() {
  nid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimulatorTradeOrder::_internal_nid() const {
  return nid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimulatorTradeOrder::nid() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeOrder.NID)
  return _internal_nid();
}
inline void SimulatorTradeOrder::_internal_set_nid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  nid_ = value;
}
inline void SimulatorTradeOrder::set_nid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_nid(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeOrder.NID)
}

// .tutorial.MarketEnum Market = 10;
inline void SimulatorTradeOrder::clear_market() {
  market_ = 0;
}
inline ::tutorial::MarketEnum SimulatorTradeOrder::_internal_market() const {
  return static_cast< ::tutorial::MarketEnum >(market_);
}
inline ::tutorial::MarketEnum SimulatorTradeOrder::market() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeOrder.Market)
  return _internal_market();
}
inline void SimulatorTradeOrder::_internal_set_market(::tutorial::MarketEnum value) {
  
  market_ = value;
}
inline void SimulatorTradeOrder::set_market(::tutorial::MarketEnum value) {
  _internal_set_market(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeOrder.Market)
}

// string OrderID = 11;
inline void SimulatorTradeOrder::clear_orderid() {
  orderid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SimulatorTradeOrder::orderid() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeOrder.OrderID)
  return _internal_orderid();
}
inline void SimulatorTradeOrder::set_orderid(const std::string& value) {
  _internal_set_orderid(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeOrder.OrderID)
}
inline std::string* SimulatorTradeOrder::mutable_orderid() {
  // @@protoc_insertion_point(field_mutable:tutorial.SimulatorTradeOrder.OrderID)
  return _internal_mutable_orderid();
}
inline const std::string& SimulatorTradeOrder::_internal_orderid() const {
  return orderid_.GetNoArena();
}
inline void SimulatorTradeOrder::_internal_set_orderid(const std::string& value) {
  
  orderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SimulatorTradeOrder::set_orderid(std::string&& value) {
  
  orderid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tutorial.SimulatorTradeOrder.OrderID)
}
inline void SimulatorTradeOrder::set_orderid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  orderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tutorial.SimulatorTradeOrder.OrderID)
}
inline void SimulatorTradeOrder::set_orderid(const char* value, size_t size) {
  
  orderid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tutorial.SimulatorTradeOrder.OrderID)
}
inline std::string* SimulatorTradeOrder::_internal_mutable_orderid() {
  
  return orderid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SimulatorTradeOrder::release_orderid() {
  // @@protoc_insertion_point(field_release:tutorial.SimulatorTradeOrder.OrderID)
  
  return orderid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SimulatorTradeOrder::set_allocated_orderid(std::string* orderid) {
  if (orderid != nullptr) {
    
  } else {
    
  }
  orderid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), orderid);
  // @@protoc_insertion_point(field_set_allocated:tutorial.SimulatorTradeOrder.OrderID)
}

// .tutorial.KindEnum Kind = 12;
inline void SimulatorTradeOrder::clear_kind() {
  kind_ = 0;
}
inline ::tutorial::KindEnum SimulatorTradeOrder::_internal_kind() const {
  return static_cast< ::tutorial::KindEnum >(kind_);
}
inline ::tutorial::KindEnum SimulatorTradeOrder::kind() const {
  // @@protoc_insertion_point(field_get:tutorial.SimulatorTradeOrder.Kind)
  return _internal_kind();
}
inline void SimulatorTradeOrder::_internal_set_kind(::tutorial::KindEnum value) {
  
  kind_ = value;
}
inline void SimulatorTradeOrder::set_kind(::tutorial::KindEnum value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:tutorial.SimulatorTradeOrder.Kind)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tutorial

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tutorial::KindEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::KindEnum>() {
  return ::tutorial::KindEnum_descriptor();
}
template <> struct is_proto_enum< ::tutorial::SideEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::SideEnum>() {
  return ::tutorial::SideEnum_descriptor();
}
template <> struct is_proto_enum< ::tutorial::OrderTypeEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::OrderTypeEnum>() {
  return ::tutorial::OrderTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::tutorial::OrderStatusEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::OrderStatusEnum>() {
  return ::tutorial::OrderStatusEnum_descriptor();
}
template <> struct is_proto_enum< ::tutorial::TimeInForceEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::TimeInForceEnum>() {
  return ::tutorial::TimeInForceEnum_descriptor();
}
template <> struct is_proto_enum< ::tutorial::MarketEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::MarketEnum>() {
  return ::tutorial::MarketEnum_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_SimulatorTradeProtos_2eproto
